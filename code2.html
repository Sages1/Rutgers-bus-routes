<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Rutgers NB Live Bus Route Finder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1021;
      --panel: #121a37;
      --muted: #7c89b6;
      --primary: #6ad1ff;
      --accent: #6effa3;
      --danger: #ff7a7a;
      --text: #eaf0ff;
      --hint: #aab4da;
    }
    html, body { margin: 0; padding: 0; background: radial-gradient(1200px 800px at 80% -20%, #1a2250 0%, #0b1021 50%); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    .wrap { max-width: 1120px; margin: 0 auto; padding: 28px 16px 48px; }
    header { display: flex; align-items: center; justify-content: space-between; gap: 12px; flex-wrap: wrap; margin-bottom: 16px; }
    h1 { margin: 0; font-size: 22px; font-weight: 700; }
    .badge { padding: 6px 10px; border-radius: 10px; background: #0e1530; color: var(--hint); font-size: 12px; border: 1px solid #1a2550; }
    .grid { display: grid; gap: 14px; grid-template-columns: repeat(12, 1fr); }
    .col-8 { grid-column: span 8; } .col-4 { grid-column: span 4; }
    @media (max-width: 980px) { .col-8, .col-4 { grid-column: span 12; } }
    .panel { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0)); border: 1px solid rgba(125,150,255,0.14); border-radius: 14px; padding: 18px; box-shadow: 0 8px 30px rgba(10,20,60,0.3), inset 0 1px 0 rgba(255,255,255,0.04); backdrop-filter: blur(4px); }
    label { display: block; font-size: 12px; color: var(--hint); margin-bottom: 6px; letter-spacing: 0.02em; }
    input, select, button {
      width: 100%; box-sizing: border-box; background: #0f1732; color: var(--text);
      border: 1px solid rgba(125,150,255,0.18); border-radius: 10px; padding: 12px; font-size: 14px; outline: none;
    }
    input:focus, select:focus { border-color: rgba(106,209,255,0.7); box-shadow: 0 0 0 3px rgba(106,209,255,0.18); }
    button { cursor: pointer; background: linear-gradient(180deg, #1a8fff, #1263f1); border: none; font-weight: 600; box-shadow: 0 10px 18px rgba(26,143,255,0.3); }
    button.secondary { background: #18224a; border: 1px solid rgba(125,150,255,0.2); box-shadow: none; }
    .row { display: flex; gap: 10px; align-items: center; }
    .row > * { flex: 1; }
    .hint { color: var(--muted); font-size: 13px; margin-top: 8px; }
    .pill { display: inline-block; padding: 4px 8px; border-radius: 999px; font-size: 12px; margin: 2px 4px 2px 0; border: 1px solid rgba(125,150,255,0.2); color: var(--hint); }
    .result { border-left: 3px solid var(--primary); padding-left: 12px; margin: 12px 0; line-height: 1.55; }
    .result h3 { margin: 0 0 6px 0; font-size: 16px; }
    .segment { margin: 10px 0; padding: 10px 12px; border-radius: 10px; background: #0d1430; border: 1px solid rgba(125,150,255,0.18); }
    .segment .route { font-weight: 700; color: var(--accent); }
    .error { color: var(--danger); }
    .divider { height: 1px; background: rgba(125,150,255,0.15); margin: 14px 0; }
    .small { font-size: 12px; color: var(--hint); }
    .score { color: var(--hint); font-size: 12px; }
    .live { color: var(--accent); font-size: 12px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; border: 1px solid rgba(125,150,255,0.25); border-bottom-width: 2px; padding: 1px 6px; border-radius: 6px; color: var(--hint); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Rutgers NB Live Bus Route Finder</h1>
      <div id="status" class="badge">Initializing…</div>
    </header>

    <div class="grid">
      <section class="panel col-8">
        <div class="row">
          <div>
            <label for="origin">Origin stop</label>
            <input list="stops" id="origin" placeholder="e.g., College Avenue Student Center" autocomplete="off" />
          </div>
          <div>
            <label for="destination">Destination stop</label>
            <input list="stops" id="destination" placeholder="e.g., Busch Student Center" autocomplete="off" />
          </div>
        </div>
        <datalist id="stops"></datalist>

        <div class="row" style="margin-top: 10px;">
          <div class="row" style="flex: 2;">
            <div>
              <label for="transferPenalty">Transfer penalty</label>
              <select id="transferPenalty">
                <option value="20" selected>High</option>
                <option value="10">Medium</option>
                <option value="5">Low</option>
                <option value="1">Minimal</option>
              </select>
            </div>
            <div>
              <label for="loopEdges">Treat loop routes as loops</label>
              <select id="loopEdges">
                <option value="auto" selected>Auto (detect “Loop”)</option>
                <option value="on">Always</option>
                <option value="off">Never</option>
              </select>
            </div>
          </div>
          <button id="findBtn">Find Best Route</button>
          <button id="swapBtn" class="secondary" title="Swap origin and destination">Swap</button>
        </div>

        <div class="hint">
          <span>Type a stop name and press Enter. Use <span class="kbd">Tab</span> to accept a suggestion.</span>
        </div>

        <div id="results"></div>
        <div id="liveEta"></div>
      </section>

      <aside class="panel col-4">
        <div class="row" style="align-items:center; justify-content: space-between;">
          <h3 style="margin: 0;">All Routes</h3>
          <button id="refreshBtn" class="secondary" style="max-width:140px;">Refresh live data</button>
        </div>
        <div id="routePills" style="margin-top: 6px;"></div>
        <div class="divider"></div>
        <div class="small">
          Live data cached briefly to reduce load. If live fetch fails, the app falls back to the static Rutgers routes you provided.
        </div>
      </aside>
    </div>
  </div>

  <script>
    // ------------------ Utilities ------------------
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    async function fetchWithTimeout(url, opts = {}) {
      const { timeout = 8000, retries = 1 } = opts;
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      try {
        const res = await fetch(url, { signal: controller.signal, cache: "no-store" });
        return res;
      } catch (e) {
        if (retries > 0) {
          await sleep(300 + Math.random() * 400);
          return fetchWithTimeout(url, { timeout, retries: retries - 1 });
        }
        throw e;
      } finally {
        clearTimeout(id);
      }
    }

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = d => d * Math.PI / 180;
      const R = 6371; // km
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    // ------------------ Normalization ------------------
    const synonyms = new Map([
      ["socam apts", "socam apartments"], ["socam", "socam apartments"], ["college ave student center", "college avenue student center"],
      ["bsc", "busch student center"], ["lsc", "livingston student center"], ["jersey mikes arena", "jersey mike's arena"],
      ["werblin", "werblin recreation center"], ["busch student", "busch student center"], ["stadium west", "stadium west lot"],
    ]);

    function canonicalize(s) {
      if (!s) return "";
      let k = s.trim().toLowerCase().replace(/\s+/g, " ");
      if (synonyms.has(k)) k = synonyms.get(k);
      return k.split(" ").map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(" ");
    }

    // ------------------ Static fallback routes (from you) ------------------
    const staticRawRoutes = {
      "A Route": ["College Avenue Student Center","The Yard","Student Activities Center","Stadium West Lot","Hill Center","Science Building","Busch Student Center","Werblin Recreation Center"],
      "B Route": ["Livingston Student Center","Quads","Hill Center","Science Building","Busch Student Center","Livingston Plaza"],
      "B/L Loop": ["Jersey Mike's Arena","Livingston Student Center","Quads","Busch Student Center","Rodkin","Stadium West Lot","Hill Center","Science Building"],
      "C Route": ["Stadium West Lot","Hill Center","Allison Road Classrooms","Hill Center"],
      "EE Route": ["College Avenue Student Center","The Yard","SoCam Apartments","Red Oak Lane","Lipman Hall","Biel Road","Henderson","Gibbons","College Hall","SoCam Apartments","Student Activities Center"],
      "F Route": ["Red Oak Lane","Lipman Hall","College Hall","Student Activities Center","The Yard"],
      "H Route": ["Busch Student Center","Allison Road Classrooms","Hill Center","Stadium West Lot","College Avenue Student Center","The Yard","Student Activities Center","Werblin Recreation Center"],
      "LX Route": ["Livingston Student Center","Quads","College Avenue Student Center","The Yard","Student Activities Center","Livingston Plaza"],
      "REXB Route": ["Red Oak Lane","Lipman Hall","College Hall","Hill Center","Allison Road Classrooms","Hill Center"],
      "REXL Route": ["Red Oak Lane","Lipman Hall","College Hall","Livingston Plaza","Livingston Student Center"],
    };

    function canonicalizeRoutes(raw) {
      const out = {};
      for (const [r, arr] of Object.entries(raw)) {
        const canon = arr.map(canonicalize).filter(Boolean);
        const dedup = [];
        for (let i=0;i<canon.length;i++) if (i===0 || canon[i] !== canon[i-1]) dedup.push(canon[i]);
        if (dedup.length >= 2) out[r] = dedup;
      }
      return out;
    }

    // ------------------ Data stores ------------------
    let routes = canonicalizeRoutes(staticRawRoutes);
    let routeColors = new Map(); // routeName -> color (if provided by live data)
    let stopsMeta = new Map();   // stopName -> {lat, lon, id?}
    let vehiclesRaw = [];        // raw vehicles array from live data (if present)
    const allStopsSet = new Set();
    let allStops = [];
    const stopToRoutes = new Map();
    const graph = new Map(); // stop -> [{to, route}]

    function clearGraph() { graph.clear(); stopToRoutes.clear(); allStopsSet.clear(); allStops.length = 0; }

    function addEdge(a, b, route) {
      if (!graph.has(a)) graph.set(a, []);
      if (!graph.has(b)) graph.set(b, []);
      graph.get(a).push({ to: b, route });
      graph.get(b).push({ to: a, route });
    }

    function rebuildIndexes(loopPolicy = "auto") {
      clearGraph();
      for (const arr of Object.values(routes)) arr.forEach(s => allStopsSet.add(s));
      allStops.push(...Array.from(allStopsSet).sort());

      for (const [rName, arr] of Object.entries(routes)) {
        arr.forEach(s => {
          if (!stopToRoutes.has(s)) stopToRoutes.set(s, new Set());
          stopToRoutes.get(s).add(rName);
        });
      }
      for (const [rName, arr] of Object.entries(routes)) {
        for (let i=0;i<arr.length-1;i++) addEdge(arr[i], arr[i+1], rName);
        const loopFlag = loopPolicy === "on" || (loopPolicy === "auto" && /loop/i.test(rName));
        if (loopFlag && arr.length >= 2) addEdge(arr[arr.length-1], arr[0], rName);
      }
      updateUILists();
    }

    // ------------------ Live data fetch & indexing ------------------
    const PASSIO_URL = "https://passiogo.com/mapGetData.php?agency=Rutgers";
    const CACHE_KEY = "passioCache_v2";
    const CACHE_MS = 60 * 1000; // 60s cache

    function readCache() {
      try {
        const raw = localStorage.getItem(CACHE_KEY);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || !obj.ts || (Date.now() - obj.ts > CACHE_MS)) return null;
        return obj.data;
      } catch { return null; }
    }

    function writeCache(data) {
      try { localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), data })); } catch {}
    }

    function normalizeStopsIndex(stops) {
      // Returns: id->stopObj map and name->meta map
      const byId = new Map();
      const byName = new Map();
      const iter = Array.isArray(stops) ? stops : Object.values(stops || {});
      for (const s of iter) {
        const id = s.id ?? s.stopId ?? s.stop_id ?? s.code ?? s.name;
        const nameRaw = s.name ?? s.stopName ?? s.stop_name ?? String(id);
        const name = canonicalize(nameRaw);
        const lat = Number(s.lat ?? s.latitude ?? s.latitide); // cope with typos
        const lon = Number(s.lon ?? s.lng ?? s.longitude);
        byId.set(String(id), { id: String(id), name, lat, lon });
        if (!byName.has(name)) byName.set(name, { id: String(id), lat, lon });
      }
      return { byId, byName };
    }

    function extractRouteStops(route, stopsIndex) {
      // Handles multiple shapes: stops = [id...], [obj...], or [name...]
      const seq = route.stops ?? route.stopIds ?? route.stop_ids ?? route.stopSequence ?? route.path ?? [];
      const out = [];
      for (const item of (seq || [])) {
        if (item == null) continue;
        if (typeof item === "string" || typeof item === "number") {
          const got = stopsIndex.byId.get(String(item));
          if (got) out.push(got.name);
        } else if (typeof item === "object") {
          const id = item.id ?? item.stopId ?? item.stop_id ?? item.code;
          const nameRaw = item.name ?? item.stopName ?? item.stop_name;
          if (id != null) {
            const got = stopsIndex.byId.get(String(id));
            if (got) out.push(got.name);
            else if (nameRaw) out.push(canonicalize(nameRaw));
          } else if (nameRaw) {
            out.push(canonicalize(nameRaw));
          }
        }
      }
      // Deduplicate immediate repeats
      const dedup = [];
      for (let i=0;i<out.length;i++) if (i===0 || out[i] !== out[i-1]) dedup.push(out[i]);
      return dedup;
    }

    function extractRouteName(r) {
      return (r.name ?? r.longName ?? r.long_name ?? r.shortName ?? r.short_name ?? `Route ${r.id ?? ""}`).toString().trim();
    }

    function extractRouteColorMap(routesArr) {
      const map = new Map();
      for (const r of routesArr) {
        const color = r.color ?? r.routeColor ?? r.textColor ?? null;
        const name = extractRouteName(r);
        if (color) map.set(name, String(color).startsWith("#") ? color : `#${color}`);
      }
      return map;
    }

    function vehiclesByRoute(vehiclesArr) {
      const map = new Map(); // routeKey(lowercased name/id) -> vehicles[]
      for (const v of vehiclesArr || []) {
        const rName = (v.routeName ?? v.route_name ?? v.routeLongName ?? v.longName ?? "").toString().trim();
        const rId = (v.routeId ?? v.route_id ?? v.route ?? v.routeShortName ?? "").toString().trim();
        const keyCandidates = [];
        if (rName) keyCandidates.push(rName.toLowerCase());
        if (rId) keyCandidates.push(rId.toLowerCase());
        for (const key of keyCandidates) {
          if (!map.has(key)) map.set(key, []);
          map.get(key).push(v);
        }
      }
      return map;
    }

    async function loadLiveData() {
      const statusEl = document.getElementById("status");
      statusEl.textContent = "Loading live data…";
      let data = readCache();
      try {
        if (!data) {
          const res = await fetchWithTimeout(PASSIO_URL, { timeout: 9000, retries: 1 });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          data = await res.json();
          writeCache(data);
        }
        // Normalize
        const routesArr = Array.isArray(data.routes) ? data.routes : Object.values(data.routes || {});
        const { byId, byName } = normalizeStopsIndex(data.stops || []);
        const rOut = {};
        for (const r of routesArr) {
          const rName = extractRouteName(r);
          const stopsSeq = extractRouteStops(r, { byId, byName });
          if (stopsSeq.length >= 2) rOut[rName] = stopsSeq;
        }
        if (Object.keys(rOut).length >= 2) {
          routes = rOut;
          routeColors = extractRouteColorMap(routesArr);
          stopsMeta = byName;
          vehiclesRaw = data.vehicles || [];
          statusEl.textContent = "Live data loaded";
          statusEl.classList.add("live");
        } else {
          throw new Error("Live data did not include usable routes");
        }
      } catch (err) {
        // Fall back to static
        routes = canonicalizeRoutes(staticRawRoutes);
        routeColors = new Map();
        stopsMeta = new Map();
        vehiclesRaw = [];
        statusEl.textContent = "Using static routes (live fetch failed)";
        statusEl.classList.remove("live");
        console.warn("Live data load failed:", err);
      }
      rebuildIndexes(document.getElementById("loopEdges").value);
    }

    // ------------------ Fuzzy matching ------------------
    function scoreCandidate(query, stop) {
      const q = query.toLowerCase(), s = stop.toLowerCase();
      if (s === q) return 1000;
      if (s.startsWith(q)) return 800;
      if (s.includes(q)) return 500;
      const qt = q.split(/\s+/), st = s.split(/\s+/);
      const overlap = qt.filter(x => st.includes(x)).length;
      return overlap * 150 - Math.abs(s.length - q.length);
    }
    function bestStopMatch(input) {
      const q = canonicalize(input);
      let best = null, bestScore = -Infinity;
      for (const s of allStops) {
        const sc = scoreCandidate(q, s);
        if (sc > bestScore) { best = s; bestScore = sc; }
      }
      return { stop: best, score: bestScore };
    }

    // ------------------ Min-heap for Dijkstra ------------------
    class MinHeap {
      constructor() { this.a = []; }
      push(x) { this.a.push(x); this.bubbleUp(this.a.length - 1); }
      pop() {
        if (this.a.length === 0) return null;
        const top = this.a[0];
        const end = this.a.pop();
        if (this.a.length) { this.a[0] = end; this.bubbleDown(0); }
        return top;
      }
      bubbleUp(i) {
        while (i > 0) {
          const p = ((i - 1) >> 1);
          if (this.a[i].cost >= this.a[p].cost) break;
          [this.a[i], this.a[p]] = [this.a[p], this.a[i]];
          i = p;
        }
      }
      bubbleDown(i) {
        const n = this.a.length;
        while (true) {
          let l = i*2+1, r = l+1, smallest = i;
          if (l < n && this.a[l].cost < this.a[smallest].cost) smallest = l;
          if (r < n && this.a[r].cost < this.a[smallest].cost) smallest = r;
          if (smallest === i) break;
          [this.a[i], this.a[smallest]] = [this.a[smallest], this.a[i]];
          i = smallest;
        }
      }
      get size() { return this.a.length; }
    }

    // ------------------ Pathfinding (Dijkstra with transfer penalty) ------------------
    function findBestPath(origin, destination, transferPenalty = 20) {
      const start = canonicalize(origin);
      const goal  = canonicalize(destination);
      if (!graph.has(start) || !graph.has(goal)) {
        return { error: "Unknown stop(s).", suggestions: suggestStops([origin, destination]) };
      }
      const key = (stop, route) => `${stop}|||${route || ""}`;
      const dist = new Map();
      const prev = new Map();
      const pq = new MinHeap();

      const startKey = key(start, null);
      dist.set(startKey, 0); pq.push({ stateKey: startKey, cost: 0 });

      while (pq.size) {
        const { stateKey, cost } = pq.pop();
        if (cost !== dist.get(stateKey)) continue;
        const [stop, routeStr] = stateKey.split("|||");
        if (stop === goal) break;

        const edges = graph.get(stop) || [];
        for (const e of edges) {
          const sameRoute = (routeStr === "" || routeStr === e.route);
          const stepCost = 1 + (sameRoute ? 0 : transferPenalty);
          const nextKey = key(e.to, e.route);
          const newCost = cost + stepCost;
          if (newCost < (dist.get(nextKey) ?? Infinity)) {
            dist.set(nextKey, newCost);
            prev.set(nextKey, { prevKey: stateKey, viaRoute: e.route, fromStop: stop });
            pq.push({ stateKey: nextKey, cost: newCost });
          }
        }
      }

      let bestGoalKey = null, bestCost = Infinity;
      for (const [k, c] of dist.entries()) {
        if (k.startsWith(goal + "|||") && c < bestCost) { bestCost = c; bestGoalKey = k; }
      }
      if (!bestGoalKey) return { error: "No path found between these stops." };

      // Reconstruct hops
      const hops = [];
      let cursor = bestGoalKey;
      while (cursor !== startKey) {
        const step = prev.get(cursor);
        if (!step) break;
        hops.push({ to: cursor.split("|||")[0], from: step.fromStop, route: step.viaRoute });
        cursor = step.prevKey;
      }
      hops.reverse();

      // Collapse to segments
      const segments = [];
      if (hops.length) {
        let seg = { route: hops[0].route, from: hops[0].from, to: hops[0].to, stops: [hops[0].from, hops[0].to] };
        for (let i=1;i<hops.length;i++) {
          if (hops[i].route === seg.route && hops[i].from === seg.stops[seg.stops.length - 1]) {
            seg.to = hops[i].to; seg.stops.push(hops[i].to);
          } else {
            segments.push(seg);
            seg = { route: hops[i].route, from: hops[i].from, to: hops[i].to, stops: [hops[i].from, hops[i].to] };
          }
        }
        segments.push(seg);
      }

      // Alternatives: direct routes containing both stops in order
      const directAlternatives = [];
      for (const [rName, arr] of Object.entries(routes)) {
        const iA = arr.indexOf(start), iB = arr.indexOf(goal);
        if (iA !== -1 && iB !== -1 && ((iB > iA) || (iB === 0 && iA === arr.length - 1))) {
          const hopsCount = (iB >= iA) ? (iB - iA) : (arr.length - iA + iB); // if loop edge used
          directAlternatives.push({ route: rName, hops: hopsCount });
        }
      }
      directAlternatives.sort((a,b) => a.hops - b.hops);

      return { segments, origin: start, destination: goal, transfers: Math.max(0, segments.length - 1), stopsCount: hops.length, directAlternatives };
    }

    function suggestStops(inputs) {
      const out = {};
      for (const s of inputs) {
        const { stop } = bestStopMatch(s);
        out[s] = stop;
      }
      return out;
    }

    // ------------------ Live bus proximity (rough ETA) ------------------
    function estimateMinutesFromKm(km) {
      // Assume ~18 km/h average operational speed (urban, stops): 0.3 km/min
      const mins = km / 0.3;
      return Math.round(mins);
    }

    function firstSegmentLiveInfo(res) {
      if (!res || !res.segments || !res.segments.length || !vehiclesRaw.length) return null;
      const seg = res.segments[0];
      const routeName = seg.route;
      const origin = seg.from;
      const originMeta = stopsMeta.get(origin);
      if (!originMeta) return null;

      const vMap = vehiclesByRoute(vehiclesRaw);
      const candLists = [
        vMap.get((routeName || "").toLowerCase()) || [],
      ];
      // Also attempt matching by route shortname in parentheses like "B/L Loop"
      const allVehs = [].concat(...candLists);
      if (!allVehs.length) return null;

      const enriched = allVehs.map(v => {
        const lat = Number(v.lat ?? v.latitude), lon = Number(v.lon ?? v.lng ?? v.longitude);
        const km = (isFinite(lat) && isFinite(lon)) ? haversine(originMeta.lat, originMeta.lon, lat, lon) : Infinity;
        const ageSec = (Date.now()/1000) - Number(v.lastUpdated ?? v.timestamp ?? v.time ?? 0);
        return { name: v.name ?? v.vehicle ?? v.id ?? "Bus", km, etaMin: isFinite(km) ? estimateMinutesFromKm(km) : null, ageSec: isFinite(ageSec) ? Math.max(0, Math.round(ageSec)) : null };
      }).filter(x => isFinite(x.km)).sort((a,b) => a.km - b.km).slice(0, 3);

      if (!enriched.length) return null;
      return { origin, routeName, buses: enriched };
    }

    // ------------------ UI wiring ------------------
    const datalist = document.getElementById("stops");
    const originEl = document.getElementById("origin");
    const destEl = document.getElementById("destination");
    const findBtn = document.getElementById("findBtn");
    const swapBtn = document.getElementById("swapBtn");
    const refreshBtn = document.getElementById("refreshBtn");
    const resultsEl = document.getElementById("results");
    const liveEtaEl = document.getElementById("liveEta");
    const routePillsEl = document.getElementById("routePills");
    const penaltyEl = document.getElementById("transferPenalty");
    const loopEdgesEl = document.getElementById("loopEdges");

    function updateUILists() {
      // Avoid heavy innerHTML churn by building once
      datalist.innerHTML = allStops.map(s => `<option value="${s}">`).join("");
      routePillsEl.innerHTML = Object.keys(routes).sort().map(r => {
        const color = routeColors.get(r) || "#1a2550";
        const style = `border-color:${color}; color:${color};`;
        return `<span class="pill" data-route="${r}" style="${style}">${r}</span>`;
      }).join("");
    }

    function renderResult(res) {
      liveEtaEl.innerHTML = "";
      if (res.error) {
        const sug = res.suggestions ? `
          <div class="hint">Did you mean:
            ${Object.entries(res.suggestions).map(([inp, s]) => `<span class="pill">${inp} → ${s}</span>`).join(" ")}
          </div>` : "";
        resultsEl.innerHTML = `<div class="result"><h3 class="error">${res.error}</h3>${sug}</div>`;
        return;
      }
      const header = `
        <div class="result">
          <h3>Best route: ${res.origin} → ${res.destination}</h3>
          <div class="score">Transfers: ${res.transfers} • Stops: ${res.stopsCount}</div>
      `;
      const segmentsHtml = res.segments.map(seg => `
        <div class="segment">
          <div><span class="route">${seg.route}</span></div>
          <div><strong>Board at:</strong> ${seg.from}</div>
          <div><strong>Ride through:</strong> ${seg.stops.slice(1, -1).join(" → ") || "—"}</div>
          <div><strong>Alight at:</strong> ${seg.to}</div>
        </div>
      `).join("");
      const alts = res.directAlternatives.filter(a => !(res.segments.length===1 && res.segments[0].route === a.route));
      const altHtml = alts.length ? `
        <div class="hint"><strong>Other direct options:</strong> ${alts.map(a => `${a.route} (${a.hops} stops)`).join(" • ")}</div>
      ` : "";
      resultsEl.innerHTML = header + segmentsHtml + altHtml + `</div>`;

      // Live proximity/ETA (if available)
      const liveInfo = firstSegmentLiveInfo(res);
      if (liveInfo) {
        const items = liveInfo.buses.map(b => {
          const eta = (b.etaMin != null && isFinite(b.etaMin)) ? `${b.etaMin} min` : "—";
          const age = (b.ageSec != null) ? ` • updated ${b.ageSec}s ago` : "";
          return `<li><strong>${b.name}:</strong> ~${b.km.toFixed(2)} km away • est ${eta}${age}</li>`;
        }).join("");
        liveEtaEl.innerHTML = `
          <div class="hint">Live activity near ${liveInfo.origin} on <strong>${liveInfo.routeName}</strong>:</div>
          <ul class="small">${items}</ul>
        `;
      }
    }

    function onFind() {
      let o = originEl.value.trim(), d = destEl.value.trim();
      if (!o || !d) {
        resultsEl.innerHTML = `<div class="result"><h3 class="error">Enter both origin and destination.</h3></div>`;
        liveEtaEl.innerHTML = "";
        return;
      }
      // Help users with fuzzy input
      if (!allStops.includes(canonicalize(o))) o = bestStopMatch(o).stop;
      if (!allStops.includes(canonicalize(d))) d = bestStopMatch(d).stop;

      rebuildIndexes(loopEdgesEl.value); // apply loop policy
      const penalty = Number(penaltyEl.value);
      const res = findBestPath(o, d, penalty);
      renderResult(res);
    }

    findBtn.addEventListener("click", onFind);
    originEl.addEventListener("keydown", e => { if (e.key === "Enter") onFind(); });
    destEl.addEventListener("keydown",